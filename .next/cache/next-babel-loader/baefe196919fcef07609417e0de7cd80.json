{"ast":null,"code":"import glob from \"glob\";\nimport matter from \"gray-matter\";\nexport const loadMarkdownFile = async path => {\n  const mdFile = await import(`./md/${path}`);\n  return {\n    path,\n    contents: mdFile.default\n  };\n};\nexport const mdToPost = file => {\n  const metadata = matter(file.contents);\n  const post = {\n    path: file.path.replace(\".md\", \"\"),\n    title: metadata.data.title || null,\n    subtitle: metadata.data.subtitle || null,\n    datePublished: metadata.data.datePublished || null,\n    tags: metadata.data.tags || null,\n    author: metadata.data.author || null,\n    authorTitle: metadata.data.authorTitle || null,\n    authorPhoto: metadata.data.authorPhoto || null,\n    bannerPhoto: metadata.data.bannerPhoto || null,\n    thumbnailPhoto: metadata.data.thumbnailPhoto || null,\n    content: metadata.content\n  };\n  if (!post.title) throw new Error(`Missing: title.`);\n  if (!post.content) throw new Error(`Missing: content.`);\n  return post;\n};\nexport const loadMarkdownFiles = async path => {\n  const blogPaths = glob.sync(`./md/${path}`);\n  const postDataList = await Promise.all(blogPaths.map(async blogPath => {\n    const mdPath = blogPath.slice(blogPath.indexOf(`md/`) + 3);\n    const mdContents = await loadMarkdownFile(`${mdPath}`);\n    return mdToPost(mdContents);\n  }));\n  postDataList.sort((a, b) => {\n    if (a.datePublished && b.datePublished) {\n      return a.datePublished - b.datePublished;\n    } else if (!a.datePublished && !b.datePublished) {\n      return 0;\n    } else if (!a.datePublished) {\n      return -1;\n    } else if (!b.datePublished) {\n      return 1;\n    }\n\n    throw new Error(\"Shouldn't be reachable\");\n  });\n  postDataList.reverse();\n  return postDataList;\n};\nexport const loadPost = async path => {\n  const file = await loadMarkdownFile(path);\n  return mdToPost(file);\n};\nexport const loadBlogPosts = async () => {\n  return await loadMarkdownFiles(`blog/*.md`);\n};","map":{"version":3,"sources":["/Users/john/src/blog/loader.ts"],"names":["glob","matter","loadMarkdownFile","path","mdFile","contents","default","mdToPost","file","metadata","post","replace","title","data","subtitle","datePublished","tags","author","authorTitle","authorPhoto","bannerPhoto","thumbnailPhoto","content","Error","loadMarkdownFiles","blogPaths","sync","postDataList","Promise","all","map","blogPath","mdPath","slice","indexOf","mdContents","sort","a","b","reverse","loadPost","loadBlogPosts"],"mappings":"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","sourcesContent":["import glob from \"glob\";\nimport matter from \"gray-matter\";\nexport type PostData = {\n  path: string;\n  title?: string;\n  subtitle?: string;\n  content: string;\n  datePublished?: number;\n  author?: string;\n  authorTitle?: string;\n  authorPhoto?: string;\n  tags?: string[];\n  bannerPhoto?: string;\n  thumbnailPhoto?: string;\n};\n\ntype RawFile = { path: string; contents: string };\n\nexport const loadMarkdownFile = async (path: string): Promise<RawFile> => {\n  const mdFile = await import(`./md/${path}`);\n  return { path, contents: mdFile.default };\n};\n\nexport const mdToPost = (file: RawFile): PostData => {\n  const metadata = matter(file.contents);\n\n  const post = {\n    path: file.path.replace(\".md\", \"\"),\n    title: metadata.data.title || null,\n    subtitle: metadata.data.subtitle || null,\n    datePublished: metadata.data.datePublished || null,\n    tags: metadata.data.tags || null,\n    author: metadata.data.author || null,\n    authorTitle: metadata.data.authorTitle || null,\n    authorPhoto: metadata.data.authorPhoto || null,\n    bannerPhoto: metadata.data.bannerPhoto || null,\n    thumbnailPhoto: metadata.data.thumbnailPhoto || null,\n    content: metadata.content,\n  };\n\n  if (!post.title) throw new Error(`Missing: title.`);\n  if (!post.content) throw new Error(`Missing: content.`);\n\n  return post as PostData;\n};\n\nexport const loadMarkdownFiles = async (path: string): Promise<PostData[]> => {\n  const blogPaths = glob.sync(`./md/${path}`);\n  const postDataList: PostData[] = await Promise.all(\n    blogPaths.map(\n      async (blogPath: string): Promise<PostData> => {\n        const mdPath = blogPath.slice(blogPath.indexOf(`md/`) + 3);\n        const mdContents = await loadMarkdownFile(`${mdPath}`);\n        return mdToPost(mdContents);\n      }\n    )\n  );\n  postDataList.sort((a: PostData, b: PostData): number => {\n    if (a.datePublished && b.datePublished) {\n      return a.datePublished - b.datePublished;\n    } else if (!a.datePublished && !b.datePublished) {\n      return 0;\n    } else if (!a.datePublished) {\n      return -1;\n    } else if (!b.datePublished) {\n      return 1;\n    }\n    throw new Error(\"Shouldn't be reachable\");\n  });\n  postDataList.reverse();\n  return postDataList;\n};\n\nexport const loadPost = async (path: string): Promise<PostData> => {\n  const file = await loadMarkdownFile(path);\n  return mdToPost(file);\n};\n\nexport const loadBlogPosts = async (): Promise<PostData[]> => {\n  return await loadMarkdownFiles(`blog/*.md`);\n};\n"]},"metadata":{},"sourceType":"module"}